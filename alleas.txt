using aff;

namespace geo
{
    public class MyForm
    {

        public Boolean rotable  =false;
        public Plot plot { get; set; }
        public Boolean rotate  =false;
        public float rotation { get; set; }
        public Color color { get; set; }
        public Polygone polygone { get; set; }
        public List<PointF> Points { get; set; }
        public List<int> IdBlock { get; set; }
        public Boolean Mikatona { set; get; }
        public List<PointF> Coordonnees { get; set; }


        //demi cercle
        public int idBlock {get;set;}  
        public float radius {get;set;}
        public float endangle {get;set;}
        public PointF center {get;set;}

        private int nbrDraw = 0;
        //forme rectiligne
        public MyForm(List<int> idBlocks, Boolean mikatona, Plot plot)
        {
            IdBlock = idBlocks;
            Mikatona = mikatona;
            Points = new List<PointF>();
            Coordonnees = new List<PointF>();
            this.plot = plot;
        }
        //forme trigonometrique
        public MyForm(int idBlock, Func<float, float> equation, float startX, float endX, Plot plot)
        {
            
            this.idBlock = idBlock;
            TerrainPanel terrainPanel = new TerrainPanel();
            terrainPanel.initilizeBlocks();
            List<MyBlock> myBlocks = new List<MyBlock>(terrainPanel.myBlocks);
            PointF center = new PointF();
            foreach (var item in myBlocks)
            {
                if (item.idBlock.Equals(idBlock))
                {
                    center = item.Center;
                    Points = new List<PointF>(Fonction.GetPointsByEquation(center, equation, startX, endX));
                    break;
                }
            }
            Coordonnees = new List<PointF>();
            this.plot = plot;
        }


        //forme circulaire
        public MyForm(int idBlock, float radius, float rotation, float endangle, Plot plot)
        {
            this.rotation = rotation;
            this.idBlock = idBlock;
            this.radius  =radius;
            this.endangle = endangle;
            this.plot = plot;

             if (rotate == null)

            {
                rotate = false;
            }
            rotable = true;
            rotate = true;
            TerrainPanel terrainPanel = new TerrainPanel();
            terrainPanel.initilizeBlocks();
            List<MyBlock> myBlocks = new List<MyBlock>(terrainPanel.myBlocks);
            PointF center = new PointF();
            foreach (var item in myBlocks)
            {
                if (item.idBlock.Equals(idBlock))
                {
                    center = item.Center;
                    Points = new List<PointF>(Fonction.GetPointsOfSemiCircle(center, radius, endangle, rotation));
                    break;
                }
            }
            this.center = center;
            Coordonnees = new List<PointF>();
        }
        public async void drawIt(Graphics g, List<MyBlock> myBlocks, Color color)
        {

            initializePoints(myBlocks);
            if (this.rotable && this.rotate)
            {   
                rotation += 1;
                this.Points = new List<PointF>(Fonction.GetPointsOfSemiCircle(center, radius, endangle, rotation));
            }
            
            Pen pen = new Pen(this.color, 3);
            PointF[] point = Points.ToArray();
            if (this.Mikatona == true)
            {
                if (MyBlock.Config)
                {
                    g.DrawLines(pen, this.polygone.Points);
                    g.DrawLine(pen, point[0], point[point.Count() - 1]);
                }

                foreach (var item in Fonction.getPointRectiligne(point[point.Count() - 1], point[0], 10))
                {
                    point = point.Concat(new PointF[] { item }).ToArray();
                }
                this.polygone.Points = point;
            }
            else
            {
                if (MyBlock.Config)
                {
                    g.DrawLines(pen, this.polygone.Points);

                }
            }
            if (plot.Point == null)
            {
                this.plot = new Plot(Points[0]);
                this.plot.Point = Points[0];
            }
            else
            {
                if (this.plot.IsMoving == false)
                {
                    // MyConsole.addLine("isMoving " + this.plot.IsMoving);
                    Task task = plot.movePlotAsync(point);
                    this.plot.IsMoving = true;
                }
                this.plot.draw(g, color);
            }
        }
        public void initializePoints(List<MyBlock> myBlocks)
        {
            if (Points.Count == 0)
            {

                for (int i = 0; i < IdBlock.Count; i++)
                {
                    foreach (var block in myBlocks)
                    {
                        if (IdBlock[i].Equals(block.idBlock))
                        {

                            Points.Add(block.Center);
                            break;
                        }
                    }

                }

            }
            this.polygone = new Polygone(Points.ToArray());
        }
    }
}
